<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Pong tutorial with ggez part 3 | Mikail Khan</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Pong tutorial with ggez part 3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is a continuation of Pong tutorial with ggez and Pong tutorial with ggez part 2." />
<meta property="og:description" content="This is a continuation of Pong tutorial with ggez and Pong tutorial with ggez part 2." />
<link rel="canonical" href="http://localhost:4000/2020/05/21/Pong-tutorial-with-ggez-Part-3.html" />
<meta property="og:url" content="http://localhost:4000/2020/05/21/Pong-tutorial-with-ggez-Part-3.html" />
<meta property="og:site_name" content="Mikail Khan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-21T00:00:00-04:00" />
<script type="application/ld+json">
{"description":"This is a continuation of Pong tutorial with ggez and Pong tutorial with ggez part 2.","url":"http://localhost:4000/2020/05/21/Pong-tutorial-with-ggez-Part-3.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/05/21/Pong-tutorial-with-ggez-Part-3.html"},"headline":"Pong tutorial with ggez part 3","dateModified":"2020-05-21T00:00:00-04:00","datePublished":"2020-05-21T00:00:00-04:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Mikail Khan" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Mikail Khan</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Pong tutorial with ggez part 3</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-05-21T00:00:00-04:00" itemprop="datePublished">May 21, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This is a continuation of <a href="https://mkhan45.github.io/2020/05/19/Pong-tutorial-with-ggez.html">Pong tutorial with ggez</a> and <a href="http://localhost:4000/2020/05/20/Pong-tutorial-with-ggez-Part-2.html">Pong tutorial with ggez part 2</a>.</p>

<p>At the end of part 2, we had finished datastructures and a working draw loop. You can find the code from part 2 <a href="https://github.com/mkhan45/ggez-pong-tutorial/tree/master/part2">here</a>.</p>

<p>In this part, we’ll finish the update loop and make Pong playable. We’re finally getting to some actual gamedev!</p>

<hr />

<p>Right now, our update function looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">fn</span> <span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">ggez</span><span class="p">::</span><span class="n">Context</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">ggez</span><span class="p">::</span><span class="n">GameResult</span> <span class="p">{</span>
     <span class="nf">Ok</span><span class="p">(())</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>To get Pong going, we need it to:</p>
<ol>
  <li>Handle some input</li>
  <li>Move the ball</li>
  <li>Handle collisions</li>
</ol>

<p>And that’s pretty much it!</p>

<hr />

<h2 id="input-handling">Input handling</h2>

<p>Input handling in ggez is roughly split into two methods. We’ve made <code class="language-plaintext highlighter-rouge">update()</code> and <code class="language-plaintext highlighter-rouge">draw()</code> methods in our <code class="language-plaintext highlighter-rouge">impl EventHandler</code> block, but <code class="language-plaintext highlighter-rouge">EventHandler</code> also specifies a few other methods including <code class="language-plaintext highlighter-rouge">key_down_event()</code>, which runs whenever a user presses a key. <code class="language-plaintext highlighter-rouge">key_down_event()</code> is great when we want to know when a button is pressed once, like if someone jumps in a platformer. It’s not good for Pong because we expect the keys to be held down. For Pong, we’ll use <a href="https://docs.rs/ggez/0.5.1/ggez/input/keyboard/fn.is_key_pressed.html"><code class="language-plaintext highlighter-rouge">ggez::input::keyboard::is_key_pressed</code></a>. All it does is tell us if a specific key is pressed during the current frame.</p>

<p>From the function signature, we can see that this function takes a reference to <code class="language-plaintext highlighter-rouge">Context</code> and a <code class="language-plaintext highlighter-rouge">ggez::input::keyboard::KeyCode</code>. <code class="language-plaintext highlighter-rouge">ggez::input::keyboard::KeyCode</code> is kind of long to type, so you could add <code class="language-plaintext highlighter-rouge">use ggez::input::keyboard::KeyCode</code> and <code class="language-plaintext highlighter-rouge">use ggez::input::keyboard::is_key_pressed</code> somewhere at the top of your file. I prefer to have the <code class="language-plaintext highlighter-rouge">keyboard</code> namespace somewhere though so I usually just <code class="language-plaintext highlighter-rouge">use ggez::input::keyboard</code> so I can just write <code class="language-plaintext highlighter-rouge">keyboard::is_key_pressed()</code> and <code class="language-plaintext highlighter-rouge">keyboard::KeyCode</code> etc.</p>

<p>I want to make the left paddle use W and S to go up and down and make the right paddle use the Up and Down arrows to move. If we look at <a href="https://docs.rs/ggez/0.5.1/ggez/input/keyboard/enum.KeyCode.html">the ggez documentation for <code class="language-plaintext highlighter-rouge">KeyCode</code></a>, we can see the proper names of all the available keycodes.</p>

<p>To detect when W is pressed, we just use:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nf">is_key_pressed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nn">KeyCode</span><span class="p">::</span><span class="n">W</span><span class="p">)</span> <span class="p">{</span>
   <span class="c">// handle W being pressed</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since we want to move the left paddle up, we can just use <code class="language-plaintext highlighter-rouge">self.l_paddle.y -= 5.0</code>. It’s important to note that like most computer graphics stuff, ggez uses (0, 0) as the top left of the screen and y goes top to bottom while x goes left to right.</p>

<p>Replicating this for the rest of the inputs, we get:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nf">is_key_pressed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nn">KeyCode</span><span class="p">::</span><span class="n">W</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.l_paddle.y</span> <span class="o">-=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nf">is_key_pressed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nn">KeyCode</span><span class="p">::</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.l_paddle.y</span> <span class="o">+=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nf">is_key_pressed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nn">KeyCode</span><span class="p">::</span><span class="n">Up</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.r_paddle.y</span> <span class="o">-=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nf">is_key_pressed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nn">keyboard</span><span class="p">::</span><span class="nn">KeyCode</span><span class="p">::</span><span class="n">Down</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.r_paddle.y</span> <span class="o">+=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>I chose 5.0 arbitrarily, but we’ll probably want to change the speed later, so it’s best to set paddle speed as a const at the start of the file:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">PADDLE_SPEED</span><span class="p">:</span> <span class="nb">f32</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
</code></pre></div></div>
<p>Remember to substitute 5.0 in your if statements with <code class="language-plaintext highlighter-rouge">PADDLE_SPEED</code>.</p>

<p>Now, if you run the game with <code class="language-plaintext highlighter-rouge">cargo run</code>, the paddles will move when you press buttons!</p>

<hr />

<h2 id="making-the-ball-move">Making the ball move</h2>

<p>Moving the ball is pretty similar to moving the paddles, except that its velocity is stored and it’s in two dimensions. We could write:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">self</span><span class="py">.ball.rect.x</span> <span class="o">+=</span> <span class="k">self</span><span class="py">.ball.vel.x</span><span class="p">;</span>
<span class="k">self</span><span class="py">.ball.rect.y</span> <span class="o">+=</span> <span class="k">self</span><span class="py">.ball.vel.y</span><span class="p">;</span>
</code></pre></div></div>

<p>However, ggez conveniently has a translate function for <code class="language-plaintext highlighter-rouge">Rect</code>, so we’ll just use that:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.translate</span><span class="p">(</span><span class="k">self</span><span class="py">.ball.vel</span><span class="p">);</span>
</code></pre></div></div>

<p>If you run the game…</p>

<p>Nothing will change. The ball’s velocity is &lt;0, 0&gt;.</p>

<p> </p>

<p>We initially hardcoded the ball’s velocity in our <code class="language-plaintext highlighter-rouge">main()</code> method when initializing our <code class="language-plaintext highlighter-rouge">MainState</code>. We could just tell it to use a random vector in <code class="language-plaintext highlighter-rouge">main()</code>, but we’re going to be resetting the ball a lot later when someone scores, so it’s best to just put it in a <code class="language-plaintext highlighter-rouge">Ball::new()</code> method.</p>

<p>To add a method to our <code class="language-plaintext highlighter-rouge">Ball</code> type, we use an <code class="language-plaintext highlighter-rouge">impl</code> block. I’d recommend putting it right after our declaration of the <code class="language-plaintext highlighter-rouge">Ball</code> struct.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Ball</span> <span class="p">{</span>
   <span class="c">//stuff</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we just copy over what we have in <code class="language-plaintext highlighter-rouge">main()</code>, we’d get:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Ball</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Ball</span> <span class="p">{</span>
            <span class="n">rect</span><span class="p">:</span> <span class="nn">Rect</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                      <span class="n">SCREEN_WIDTH</span> <span class="err">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">BALL_RADIUS</span> <span class="err">/</span> <span class="mf">2.0</span><span class="p">,</span>
                      <span class="n">SCREEN_HEIGHT</span> <span class="err">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">BALL_RADIUS</span> <span class="err">/</span> <span class="mf">2.0</span><span class="p">,</span>
                      <span class="n">BALL_RADIUS</span><span class="p">,</span>
                      <span class="n">BALL_RADIUS</span><span class="p">,</span>
                  <span class="p">),</span>
                  <span class="n">vel</span><span class="p">:</span> <span class="n">Vector</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span> <span class="p">},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note: the signature <code class="language-plaintext highlighter-rouge">fn new() -&gt; Self</code> indicates that this function returns a ball because in an <code class="language-plaintext highlighter-rouge">impl</code> block, <code class="language-plaintext highlighter-rouge">Self</code> is just an alias for whatever is being <code class="language-plaintext highlighter-rouge">impl</code>‘d. We could also use <code class="language-plaintext highlighter-rouge">fn new() -&gt; Ball</code> but in <code class="language-plaintext highlighter-rouge">new()</code> methods I think it’s more standard to use <code class="language-plaintext highlighter-rouge">Self</code>.</p>

<p>We need to change <code class="language-plaintext highlighter-rouge">vel: Vector { x: 0.0, y: 0.0 }</code> to use a random vector. Rust doesn’t actually have random number generation in its standard library, but the <code class="language-plaintext highlighter-rouge">rand</code> crate/library is the standard way to do it. To add <code class="language-plaintext highlighter-rouge">rand</code> as a dependency, just add <code class="language-plaintext highlighter-rouge">rand = "0.7.3" to the </code>[dependencies]<code class="language-plaintext highlighter-rouge"> section of your </code>Cargo.toml`.</p>

<p>The function I most use from <code class="language-plaintext highlighter-rouge">rand</code> is <a href="https://docs.rs/rand/0.7.3/rand/trait.Rng.html#method.gen_range"><code class="language-plaintext highlighter-rouge">Rng::gen_range()</code></a>. Here’s the example usage from the <code class="language-plaintext highlighter-rouge">rand</code> documentation:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">rand</span><span class="p">::{</span><span class="n">thread_rng</span><span class="p">,</span> <span class="n">Rng</span><span class="p">};</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nf">thread_rng</span><span class="p">();</span>
<span class="k">let</span> <span class="n">n</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="k">let</span> <span class="n">m</span><span class="p">:</span> <span class="nb">f64</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="o">-</span><span class="mf">40.0f64</span><span class="p">,</span> <span class="mf">1.3e5f64</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</code></pre></div></div>

<p>We’re not going to use <code class="language-plaintext highlighter-rouge">rand</code> anywhere other than in <code class="language-plaintext highlighter-rouge">Ball::new()</code>, so it’s safe to scope the <code class="language-plaintext highlighter-rouge">use rand::{thread_rng, Rng}</code> to just this function. The possible starting values we want for the ball’s velocity are kind of weird. It would be bad for the velocity to be 0, but it should be possible for it to be negative. Usually I implement this with <code class="language-plaintext highlighter-rouge">rng.gen_range(min_vel, max_vel)</code> and then use a coin flip to determine whether or not to multiply it by negative one. For a coin flip, we can use <code class="language-plaintext highlighter-rouge">rng.gen::&lt;Bool&gt;()</code>.</p>

<p>We also need to do everything twice. Since the x and y velocities need to be different, we can’t reuse our <code class="language-plaintext highlighter-rouge">rng.gen_range()</code>.
Here’s what my <code class="language-plaintext highlighter-rouge">Ball::new()</code> ends up as.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
     <span class="k">use</span> <span class="nn">rand</span><span class="p">::{</span><span class="n">thread_rng</span><span class="p">,</span> <span class="n">Rng</span><span class="p">};</span>

     <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nf">thread_rng</span><span class="p">();</span> <span class="c">// initialize random number generator</span>
     <span class="k">let</span> <span class="k">mut</span> <span class="n">x_vel</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span> <span class="c">// generate random float from 3 to 5</span>
     <span class="k">let</span> <span class="k">mut</span> <span class="n">y_vel</span> <span class="o">=</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>

     <span class="c">// rng.gen::&lt;bool&gt; generates either true or false with a 50% chance of each</span>
     <span class="k">if</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
         <span class="n">x_vel</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">if</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
         <span class="n">y_vel</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">Ball</span> <span class="p">{</span>
         <span class="n">rect</span><span class="p">:</span> <span class="nn">Rect</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
             <span class="n">SCREEN_WIDTH</span> <span class="err">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">BALL_RADIUS</span> <span class="err">/</span> <span class="mf">2.0</span><span class="p">,</span>
             <span class="n">SCREEN_HEIGHT</span> <span class="err">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">BALL_RADIUS</span> <span class="err">/</span> <span class="mf">2.0</span><span class="p">,</span>
             <span class="n">BALL_RADIUS</span><span class="p">,</span>
             <span class="n">BALL_RADIUS</span><span class="p">,</span>
         <span class="p">),</span>
         <span class="n">vel</span><span class="p">:</span> <span class="n">Vector</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x_vel</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y_vel</span> <span class="p">},</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>I used 3.0 and 5.0 as the bounds of <code class="language-plaintext highlighter-rouge">gen_range</code> arbitrarily, so as usual replace them with consts.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">MIN_VEL</span><span class="p">:</span> <span class="nb">f32</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">MAX_VEL</span><span class="p">:</span> <span class="nb">f32</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
</code></pre></div></div>

<p>We need to replace our hardcoded ball initialization in <code class="language-plaintext highlighter-rouge">main()</code> with this, so instead of using <code class="language-plaintext highlighter-rouge">ball: Ball { ... }</code>, we can just use <code class="language-plaintext highlighter-rouge">ball: Ball::new()</code>.</p>

<p>Now, if you run the game, the ball will move! If you keep rerunning you’ll see that it always goes a different direction.</p>

<hr />

<h2 id="collisions">Collisions</h2>

<p>As it turns out, collision detection and handling is pretty easy. ggez provides a <code class="language-plaintext highlighter-rouge">.overlaps()</code> method for <code class="language-plaintext highlighter-rouge">Rect</code>, and since our paddles and ball all have a <code class="language-plaintext highlighter-rouge">Rect</code>, we can use it.</p>

<p>In proper Pong, you want the ball to behave differently depending on where on the paddle it collides. For simplicity though, we’ll just reverse the x direction.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.overlaps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.l_paddle</span><span class="p">)</span> <span class="p">||</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.overlaps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.r_paddle</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.ball.vel.x</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>It’s good practice to also check that the ball is going towards the paddle it’s collided with:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="k">self</span><span class="py">.ball.vel.x</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.overlaps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.l_paddle</span><span class="p">))</span>
      <span class="p">||</span> <span class="p">(</span><span class="k">self</span><span class="py">.ball.vel.x</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.overlaps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.r_paddle</span><span class="p">))</span>
  <span class="p">{</span>
      <span class="k">self</span><span class="py">.ball.vel.x</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>As it turns out, it’s really hard to catch the ball with a paddle before it goes flying off into nowhere. I’ve upped <code class="language-plaintext highlighter-rouge">PADDLE_SPEED</code> to 8.</p>

<p>We also need to make the ball bounce off the top and bottom walls. This is pretty easy. ggez provides <code class="language-plaintext highlighter-rouge">top()</code> and <code class="language-plaintext highlighter-rouge">bottom()</code> methods for <code class="language-plaintext highlighter-rouge">Rect</code> which makes things even simpler.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="k">self</span><span class="py">.ball.vel.y</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.top</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
      <span class="p">||</span> <span class="p">(</span><span class="k">self</span><span class="py">.ball.vel.y</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.bottom</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">self</span><span class="py">.ball.vel.y</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>After adding these lines, the game is more or less playable.</p>

<h2 id="scorekeeping">Scorekeeping</h2>

<p>Scorekeeping is pretty much the same as collision handling. If the ball goes off the left side of the screen, reset it and add one to the right paddle’s score and vice versa. Usually I also add a small pause before the ball resets. Ideally the paddles can still move before the reset, but for simplicity we’ll just pause the whole game for a second.</p>

<p>In Rust, we pause a thread with <a href="https://doc.rust-lang.org/std/thread/fn.sleep.html"><code class="language-plaintext highlighter-rouge">std::thread::sleep</code></a>. It takes a <code class="language-plaintext highlighter-rouge">std::time::Duration</code> which we can make using <code class="language-plaintext highlighter-rouge">Duration::from_millis()</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.left</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.r_score</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
      <span class="k">self</span><span class="py">.ball</span> <span class="o">=</span> <span class="nn">Ball</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="k">self</span><span class="py">.ball.rect</span><span class="nf">.right</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">SCREEN_WIDTH</span> <span class="p">{</span>
      <span class="k">self</span><span class="py">.l_score</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
      <span class="k">self</span><span class="py">.ball</span> <span class="o">=</span> <span class="nn">Ball</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>There’s some duplicated code here, but it seems overkill to make a function just for this.</p>

<h2 id="drawing-the-score">Drawing the score</h2>

<p>I probably should’ve included this in the last part, but I forgot.</p>

<p>We want text to be drawn over everything else, so we should put it at the very end of <code class="language-plaintext highlighter-rouge">draw()</code>. Text in ggez is represented by <code class="language-plaintext highlighter-rouge">ggez::graphics::Text</code>.</p>

<p>For simplicity, I want to use only one piece of text for the scoreboard. We’ll put it in the top center of the screen with the format “L: {score} [tab] R: {score}”.</p>

<p>To make our score string, we can use <code class="language-plaintext highlighter-rouge">format!()</code>. If you’ve used <code class="language-plaintext highlighter-rouge">println!()</code>, you already know how <code class="language-plaintext highlighter-rouge">format()</code> works. Our string can be written with <code class="language-plaintext highlighter-rouge">format!("L: {} \t R: {}", self.l_score, self.r_score)</code>. We can make a <code class="language-plaintext highlighter-rouge">ggez::graphics::Text</code> instance out of it with <code class="language-plaintext highlighter-rouge">graphics::Text::new()</code>.</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">scoreboard_text</span> <span class="o">=</span> 
   <span class="nn">graphics</span><span class="p">::</span><span class="nn">Text</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"L: {} </span><span class="se">\t</span><span class="s"> R: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.l_score</span><span class="p">,</span> <span class="k">self</span><span class="py">.r_score</span><span class="p">));</span>
</code></pre></div></div>

<p>In general, you shouldn’t call <code class="language-plaintext highlighter-rouge">Text::new()</code> in your draw loop. Text rendering is fairly expensive, so you should cache it and call <code class="language-plaintext highlighter-rouge">Text::new()</code> only when the text changes.`</p>

<p>To center our text, we need to use <code class="language-plaintext highlighter-rouge">DrawParam</code>. Previously, we just used <code class="language-plaintext highlighter-rouge">DrawParam::default()</code> but since <code class="language-plaintext highlighter-rouge">graphics::Text</code> doesn’t have any position data it needs to use <code class="language-plaintext highlighter-rouge">DrawParam</code> to change location.</p>

<p>The <a href="https://docs.rs/ggez/0.5.1/ggez/graphics/struct.DrawParam.html">documentation for <code class="language-plaintext highlighter-rouge">DrawParam</code></a> tells us that we can use <code class="language-plaintext highlighter-rouge">DrawParam::dest()</code> to change the location. The input to dest is a <code class="language-plaintext highlighter-rouge">Point2&lt;f32&gt;</code>, but <code class="language-plaintext highlighter-rouge">Point2&lt;f32&gt;</code> implements <code class="language-plaintext highlighter-rouge">From&lt;[f32; 2]&gt;</code>, meaning that we can just use an array of two f32s.</p>

<p><code class="language-plaintext highlighter-rouge">graphics::Text</code> has a <code class="language-plaintext highlighter-rouge">width()</code> method so we have everything we need to make our coordinates and our <code class="language-plaintext highlighter-rouge">DrawParam</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">SCREEN_WIDTH</span> <span class="err">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">scoreboard_text</span><span class="nf">.width</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">];</span>
<span class="k">let</span> <span class="n">params</span> <span class="o">=</span> <span class="nn">graphics</span><span class="p">::</span><span class="nn">DrawParam</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span><span class="nf">.dest</span><span class="p">(</span><span class="n">coords</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">graphics::Text</code> implements <code class="language-plaintext highlighter-rouge">Drawable</code>, so we can just draw it with <code class="language-plaintext highlighter-rouge">graphics::draw()</code> as usual:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">graphics</span><span class="p">::</span><span class="nf">draw</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scoreboard_text</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"error drawing scoreboard text"</span><span class="p">);</span>
</code></pre></div></div>

<p>If you run it, you’ll see the text at the top of the screen! It’s kind of small though. <code class="language-plaintext highlighter-rouge">graphics::Text</code> has a <code class="language-plaintext highlighter-rouge">set_font()</code> method which also has <code class="language-plaintext highlighter-rouge">font_scale</code> as an argument. You can, of course, use this to use a custom font with <code class="language-plaintext highlighter-rouge">Font::new()</code>, but for simplicity we’ll just use ggez’s default font with <code class="language-plaintext highlighter-rouge">Font::default()</code>. The <code class="language-plaintext highlighter-rouge">font_scale</code> argument has to be a <code class="language-plaintext highlighter-rouge">graphics::Scale</code> object, so we’ll use <code class="language-plaintext highlighter-rouge">Scale::uniform()</code> to make sure the aspect ratio of the font is maintained.</p>

<p>We have to set the font scale before we calculate the coordinates otherwise it will be off center. We also have to make <code class="language-plaintext highlighter-rouge">scoreboard_text</code> mutable. Here’s the finished scoreboard drawing code:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="k">mut</span> <span class="n">scoreboard_text</span> <span class="o">=</span>
      <span class="nn">graphics</span><span class="p">::</span><span class="nn">Text</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"L: {} </span><span class="se">\t</span><span class="s"> R: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.l_score</span><span class="p">,</span> <span class="k">self</span><span class="py">.r_score</span><span class="p">));</span>
  <span class="n">scoreboard_text</span><span class="nf">.set_font</span><span class="p">(</span><span class="nn">graphics</span><span class="p">::</span><span class="nn">Font</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span> <span class="nn">graphics</span><span class="p">::</span><span class="nn">Scale</span><span class="p">::</span><span class="nf">uniform</span><span class="p">(</span><span class="mf">24.0</span><span class="p">));</span>

  <span class="k">let</span> <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">SCREEN_WIDTH</span> <span class="err">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">scoreboard_text</span><span class="nf">.width</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">2.0</span><span class="p">,</span>
      <span class="mf">10.0</span><span class="p">,</span>
  <span class="p">];</span>

  <span class="k">let</span> <span class="n">params</span> <span class="o">=</span> <span class="nn">graphics</span><span class="p">::</span><span class="nn">DrawParam</span><span class="p">::</span><span class="nf">default</span><span class="p">()</span><span class="nf">.dest</span><span class="p">(</span><span class="n">coords</span><span class="p">);</span>
  <span class="nn">graphics</span><span class="p">::</span><span class="nf">draw</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scoreboard_text</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"error drawing scoreboard text"</span><span class="p">);</span>
</code></pre></div></div>

<p>And, with that, pong is done!</p>

<hr />

<p> </p>

<p>You can find the completed code on github <a href="https://github.com/mkhan45/ggez-pong-tutorial/tree/master/part3">here</a>.</p>

<p>To learn more, you could expand on this by changing how paddle-ball collisions work. You could also write a simple AI and make it singleplayer.</p>

<p>This is the first long tutorial I’ve written, so if you have any feedback please email me at mikail.khan45@gmail.com</p>

  </div><a class="u-url" href="/2020/05/21/Pong-tutorial-with-ggez-Part-3.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Mikail Khan</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mikail Khan</li><li><a class="u-email" href="mailto:mikail.khan45@gmail.com">mikail.khan45@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/mkhan45"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mkhan45</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>¯\_(ツ)_/¯</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
